/*******************************************************************************
 * Copyright (c) 2010 Bryan Hunt & Ed Merks.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Bryan Hunt & Ed Merks - initial API and implementation
 *******************************************************************************/

package org.eclipselabs.mongo.emf;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import org.bson.types.ObjectId;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcorePackage;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.URIConverter;
import org.eclipse.emf.ecore.resource.impl.URIHandlerImpl;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.xmi.XMLResource;
import org.eclipselabs.mongo.IMongoDB;
import org.eclipselabs.mongo.internal.emf.Activator;

import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.DBObject;
import com.mongodb.DBRef;
import com.mongodb.Mongo;
import com.mongodb.MongoURI;

/**
 * This EMF URI handler interfaces to MongoDB. This URI handler can handle URIs with the "mongo"
 * scheme. The URI path must be of the form /database/collection/{id} where id is optional the first
 * time the EMF object is saved. Note that if the id is not specified when the object is first
 * saved, MongoDB will assign the id and the URI of the EMF Resource will be modified to include the
 * id in the URI. Examples of valid URIs:
 * 
 * mongo://localhost/data/people
 * mongo://localhost/data/people/
 * mongo://localhost/data/people/4d0a3e259095b5b334a59df0
 * 
 * @author bhunt
 * 
 */
public class MongoDBURIHandlerImpl extends URIHandlerImpl
{
	public static final String OPTION_GENERATE_ID = "org.eclipselabs.mongo.emf.genId";

	static final String ID_KEY = "_id";
	static final String EPACKAGE_KEY = "_ePackage";
	static final String ECLASS_KEY = "_eClass";
	static final String PROXY_KEY = "_eProxyURI";

	@Override
	public boolean canHandle(URI uri)
	{
		// This handler should only accept URIs with the scheme "mongo"

		return "mongo".equalsIgnoreCase(uri.scheme());
	}

	@Override
	public void delete(URI uri, Map<?, ?> options) throws IOException
	{
		// It is assumed that delete is called with the URI path /database/collection/id

		DBCollection collection = getCollection(uri);
		collection.findAndRemove(new BasicDBObject(ID_KEY, getID(uri)));
	}

	@Override
	public OutputStream createOutputStream(final URI uri, final Map<?, ?> options) throws IOException
	{
		// This function may be called with a URI path with or without an id. If an id is not specified
		// the EMF resource URI will be modified to include the id generated by MongoDB.

		return new MongoDBOutputStream()
		{
			@Override
			public void close() throws IOException
			{
				super.close();
				EObject root = resource.getContents().get(0);
				DBCollection collection = getCollection(uri);

				// We need to set up the XMLResource.URIHandler so that proxy URIs are handled properly.

				XMLResource.URIHandler uriHandler = (XMLResource.URIHandler) options.get(XMLResource.OPTION_URI_HANDLER);

				if (uriHandler == null)
					uriHandler = new org.eclipse.emf.ecore.xmi.impl.URIHandlerImpl();

				if (resource.getURI().hasTrailingPathSeparator())
					uriHandler.setBaseURI(resource.getURI());
				else
					uriHandler.setBaseURI(resource.getURI().appendSegment(""));

				// Build a MongoDB object from the EMF object.

				DBObject dbObject = buildDBObject(collection.getDB(), root, uriHandler);
				ObjectId id = getID(uri);

				if (id == null)
				{
					// The id was not specified in the URI, so we are creating an object for the first time.

					collection.insert(dbObject);
					id = (ObjectId) dbObject.get(ID_KEY);
					Map<Object, Object> response = getResponse(options);

					// Since MongoDB assigns an id to the inserted object, we need to modify the EMF Resource
					// URI to include the generated id.

					URI newURI = null;

					if (resource.getURI().hasTrailingPathSeparator())
						newURI = resource.getURI().trimSegments(1).appendSegment(id.toString());
					else
						newURI = resource.getURI().appendSegment(id.toString());

					// The EMF framework will do the actual modification of the Resource URI if the new URI is
					// set in the response options.

					response.put(URIConverter.RESPONSE_URI, newURI);
				}
				else
				{
					// The object id was specified, so we are either doing an update, or inserting a new
					// object. If the save option OPTION_GENERATE_ID is specified and set to false, we assume
					// the client is generating the id and we insert the object. Under all other conditions,
					// we update the object.

					Boolean genId = (Boolean) options.get(OPTION_GENERATE_ID);

					dbObject.put(ID_KEY, id);

					if (genId != null && !genId)
						collection.insert(dbObject);
					else
						collection.findAndModify(new BasicDBObject(ID_KEY, id), dbObject);
				}
			}
		};
	}

	public static class MongoDBOutputStream extends ByteArrayOutputStream implements URIConverter.Savable
	{
		protected Resource resource;

		@Override
		public void saveResource(Resource resource)
		{
			this.resource = resource;
		}
	}

	@Override
	public InputStream createInputStream(final URI uri, final Map<?, ?> options) throws IOException
	{
		return new MongoDBInputStream()
		{
			@Override
			public void loadResource(Resource resource) throws IOException
			{
				// We need to set up the XMLResource.URIHandler so that proxy URIs are handled properly.

				XMLResource.URIHandler uriHandler = (XMLResource.URIHandler) options.get(XMLResource.OPTION_URI_HANDLER);

				if (uriHandler == null)
					uriHandler = new org.eclipse.emf.ecore.xmi.impl.URIHandlerImpl();

				// The base URI of the handler must have a trailing path seperator "/".

				if (resource.getURI().hasTrailingPathSeparator())
					uriHandler.setBaseURI(resource.getURI());
				else
					uriHandler.setBaseURI(resource.getURI().appendSegment(""));

				// Simply get the object from MongoDB using the id and build an EMF object.

				DBCollection collection = getCollection(uri);
				DBObject dbObject = collection.findOne(new BasicDBObject(ID_KEY, getID(uri)));

				if (dbObject != null)
					resource.getContents().add(buildObject(collection, dbObject, resource, uriHandler));
			}
		};
	}

	public abstract static class MongoDBInputStream extends InputStream implements URIConverter.Loadable
	{
		@Override
		public int read() throws IOException
		{
			return 0;
		}
	}

	private ObjectId getID(URI uri) throws IOException
	{
		// We assume that the URI path has the form /database/collection/{id} making the id segment # 2.

		if (uri.segmentCount() < 2 || uri.segmentCount() > 3)
			throw new IOException("The URI is not of the form 'mongo:/database/collection/{id}");

		if (uri.segmentCount() == 2)
			return null;

		String id = uri.segment(2);

		return id.isEmpty() ? null : new ObjectId(uri.segment(2));
	}

	private DBCollection getCollection(URI uri) throws UnknownHostException, IOException
	{
		// We assume that the URI path has the form hostname:port/database/collection/{id} making the
		// collection segment # 1.

		if (uri.segmentCount() < 2 || uri.segmentCount() > 3)
			throw new IOException("The URI is not of the form 'mongo:/database/collection/{id}");

		IMongoDB mongoDB = Activator.getInstance().getMongoDB();

		if (mongoDB == null)
			throw new IOException("MongoDB service is unavailable");

		String port = uri.port();
		MongoURI mongoURI = new MongoURI("mongodb://" + uri.host() + (port != null ? ":" + port : ""));
		Mongo mongo = mongoDB.getMongo(mongoURI);

		if (mongo == null)
			throw new IOException("Could not find MongoDB host: " + mongoURI);

		DB db = mongo.getDB(uri.segment(0));

		if (db == null)
			throw new IOException("Could not find Mongo database: " + uri.segment(0));

		DBCollection collection = db.getCollection(uri.segment(1));
		return collection;
	}

	private DBObject buildDBObject(DB db, EObject eObject, XMLResource.URIHandler uriHandler) throws UnknownHostException, IOException
	{
		// Build a MongoDB object from the EMF object.

		BasicDBObject dbObject = new BasicDBObject();
		EClass eClass = eObject.eClass();

		// We have to add the package namespace URI and eclass name to the object so that we can
		// reconstruct the EMF object when we read it back out of MongoDB.

		dbObject.put(EPACKAGE_KEY, eClass.getEPackage().getNsURI());
		dbObject.put(ECLASS_KEY, eClass.getName());

		// All attributes are mapped as key / value pairs with the key being the attribute name.

		for (EAttribute attribute : eClass.getEAllAttributes())
		{
			if (!attribute.isTransient())
			{

				Object value = eObject.eGet(attribute);

				if (!nativeTypes.contains(attribute.getEAttributeType()))
					value = EcoreUtil.convertToString(attribute.getEAttributeType(), value);

				dbObject.put(attribute.getName(), value);
			}
		}

		// All references are mapped as key / value pairs with the key being the reference name.

		for (EReference reference : eClass.getEAllReferences())
		{
			if (reference.isTransient())
				continue;

			if (reference.isMany())
			{
				// One to many reference

				@SuppressWarnings("unchecked")
				EList<EObject> targetObjects = (EList<EObject>) eObject.eGet(reference);
				ArrayList<Object> dbReferences = new ArrayList<Object>(targetObjects.size());

				for (EObject targetObject : targetObjects)
					dbReferences.add(buildDBReference(db, reference, targetObject, uriHandler));

				dbObject.put(reference.getName(), dbReferences);
			}
			else
			{
				// One to one reference

				EObject targetObject = (EObject) eObject.eGet(reference);

				if (targetObject == null)
					continue;

				dbObject.put(reference.getName(), buildDBReference(db, reference, targetObject, uriHandler));
			}
		}

		return dbObject;
	}

	private Object buildDBReference(DB db, EReference eReference, EObject targetObject, XMLResource.URIHandler uriHandler) throws UnknownHostException, IOException
	{
		InternalEObject internalEObject = (InternalEObject) targetObject;

		if (eReference.isResolveProxies())
		{
			// Cross-document containment, or non-containment reference - build a proxy

			Resource resource = targetObject.eResource();

			if (internalEObject.eDirectResource() == null || !canHandle(resource.getResourceSet().getURIConverter().normalize(resource.getURI())))
			{
				BasicDBObject dbObject = new BasicDBObject(2);
				dbObject.put(PROXY_KEY, uriHandler.deresolve(EcoreUtil.getURI(targetObject)).toString());
				dbObject.put(EPACKAGE_KEY, targetObject.eClass().getEPackage().getNsURI());
				dbObject.put(ECLASS_KEY, targetObject.eClass().getName());
				return dbObject;
			}
			else
			{
				URI normalizedTargetURI = resource.getResourceSet().getURIConverter().normalize(resource.getURI());
				return new DBRef(db, getCollection(normalizedTargetURI).getName(), getID(normalizedTargetURI));
			}
		}
		else
		{
			// Non cross-document containment reference - build a MongoDB embedded object

			return buildDBObject(db, targetObject, uriHandler);
		}
	}

	private EObject buildObject(DBCollection collection, DBObject dbObject, Resource resource, XMLResource.URIHandler uriHandler)
	{
		// Build an EMF object from the MongodDB object

		EObject eObject = buildObject(dbObject);

		// All attributes are mapped as key / value pairs with the key being the attribute name.

		for (EAttribute attribute : eObject.eClass().getEAllAttributes())
		{
			if (!attribute.isTransient())
			{
				Object value = dbObject.get(attribute.getName());

				if (!nativeTypes.contains(attribute.getEAttributeType()))
					value = EcoreUtil.createFromString(attribute.getEAttributeType(), (String) value);
				else if (EcorePackage.Literals.EBYTE.equals(attribute.getEAttributeType()) || EcorePackage.Literals.EBYTE_OBJECT.equals(attribute.getEAttributeType()))
					value = ((Integer) value).byteValue();
				else if (EcorePackage.Literals.EFLOAT.equals(attribute.getEAttributeType()) || EcorePackage.Literals.EFLOAT_OBJECT.equals(attribute.getEAttributeType()))
					value = ((Double) value).floatValue();

				eObject.eSet(attribute, value);
			}
		}

		// All references are mapped as key / value pairs with the key being the reference name.

		for (EReference reference : eObject.eClass().getEAllReferences())
		{
			if (reference.isTransient())
				continue;

			if (reference.isMany())
			{
				@SuppressWarnings("unchecked")
				List<Object> dbReferences = (List<Object>) dbObject.get(reference.getName());

				if (dbReferences != null)
				{
					@SuppressWarnings("unchecked")
					EList<EObject> eObjects = (EList<EObject>) eObject.eGet(reference);

					for (Object dbReference : dbReferences)
						eObjects.add(buildObjectReference(collection, dbReference, resource, uriHandler));
				}
			}
			else
				eObject.eSet(reference, buildObjectReference(collection, dbObject.get(reference.getName()), resource, uriHandler));
		}

		return eObject;
	}

	private EObject buildObjectReference(DBCollection collection, Object dbReference, Resource resource, XMLResource.URIHandler uriHandler)
	{
		// Build an EMF reference from the data in MongoDB.

		if (dbReference instanceof DBRef)
			return buildProxy((DBRef) dbReference, resource, uriHandler);
		else
		{
			DBObject dbObject = (DBObject) dbReference;
			String proxy = (String) dbObject.get(PROXY_KEY);

			if (proxy == null)
				return buildObject(collection, dbObject, resource, uriHandler);
			else
				return buildProxy(dbObject, uriHandler);
		}
	}

	private EObject buildProxy(DBObject dbObject, XMLResource.URIHandler uriHandler)
	{
		EObject eObject = buildObject(dbObject);
		((InternalEObject) eObject).eSetProxyURI(uriHandler.resolve(URI.createURI((String) dbObject.get(PROXY_KEY))));
		return eObject;
	}

	private EObject buildProxy(DBRef dbReference, Resource resource, XMLResource.URIHandler uriHandler)
	{
		EObject eObject = buildObject(dbReference.fetch());
		URI proxyURI = URI.createURI("../../../" + dbReference.getDB().getName() + "/" + dbReference.getRef() + "/" + dbReference.getId() + "#/0");
		((InternalEObject) eObject).eSetProxyURI(uriHandler.resolve(proxyURI));
		return eObject;
	}

	private EObject buildObject(DBObject dbObject)
	{
		EPackage ePackage = EPackage.Registry.INSTANCE.getEPackage((String) dbObject.get(EPACKAGE_KEY));
		EClass eClass = (EClass) ePackage.getEClassifier((String) dbObject.get(ECLASS_KEY));
		return EcoreUtil.create(eClass);
	}

	private static HashSet<EDataType> nativeTypes = new HashSet<EDataType>();

	static
	{
		nativeTypes.add(EcorePackage.Literals.EBOOLEAN);
		nativeTypes.add(EcorePackage.Literals.EBOOLEAN_OBJECT);
		nativeTypes.add(EcorePackage.Literals.EBYTE);
		nativeTypes.add(EcorePackage.Literals.EBYTE_OBJECT);
		nativeTypes.add(EcorePackage.Literals.EBYTE_ARRAY);
		nativeTypes.add(EcorePackage.Literals.EINT);
		nativeTypes.add(EcorePackage.Literals.EINTEGER_OBJECT);
		nativeTypes.add(EcorePackage.Literals.ELONG);
		nativeTypes.add(EcorePackage.Literals.ELONG_OBJECT);
		nativeTypes.add(EcorePackage.Literals.EDOUBLE);
		nativeTypes.add(EcorePackage.Literals.EDOUBLE_OBJECT);
		nativeTypes.add(EcorePackage.Literals.EFLOAT);
		nativeTypes.add(EcorePackage.Literals.EFLOAT_OBJECT);
		nativeTypes.add(EcorePackage.Literals.EDATE);
		nativeTypes.add(EcorePackage.Literals.ESTRING);
	}
}
